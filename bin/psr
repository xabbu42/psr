#!/usr/bin/env perl

=head1 NAME

psr - perl surfraw

=head1 SYNOPSIS

psr [options] [provider] [query]

 Options:
  -h, --help            show brief help message
  --man                 show complete man page
  -f, --first, --lucky  open first result (same as --open 1)
  -a, --all             open all results (same as --open 1-)
  -o, --open=RANGES     open this results (example "1-4,5,9-")
  -u, --url             print url(s) instead of opening browser
  -n, --num=NUM         number of results to get
  -l, --list            list results (same as --all --url)
  -p, --providers       list known providers
  --browser=CMD         use CMD to open a new browser
  -t, --tabs            open all urls with one browser command 
  -w, --windows         open each url with seperate browser command
  -d, --dump            dump page to stdout
  -r, --read=FILE       read web page from FILE instead of web
  -c, --config=FILE     read config file FILE with more search providers [~/.psrrc]
  --configdir=DIR       read config files in directory DIR with more search providers [~/.psr]

=head1 DESCRIPTION

B<This program> is a perl replacement of surfraw. It generates search
urls and opens the url in a browser. You can optionally list the
results in your terminal or open the first result directly.

psr tries to use the default browser on most systems. You can
overwrite the used browser command by setting the environment variable
BROWSER or by giving an explicit browser argument.

=head1 PROVIDER CONFIGS

Additional providers can be configured in the config file ~/.psrrc or
in one file per provider in the directory ~/.psr. All of this files
are in the L<YAML|http://yaml.org> format.  ~/.psrrc should contain a
YAML hash with one hash value per additional provider under the
provider name as key. The files in ~/.psr should contain a YAML hash
with the additional provider.

A search provider config hash can contain the following keys:

=over 4

=item url

The base url for the search.

=item params

The parameters to add to the search url. The parameter values are perl
strings and the variables $query and $numresults can be used to get
the query and the number of results.

=item results

This is a bit of perl code to generate a L<Web::Scraper> object to
scrape the results from the returned html page.

=item key (only in ~/.psr)

The key of the provider (the filename is used as default). This can be
a regular expression like C<google|g> if different arguments
should match this provider. 

=back

=head1 AUTHOR

Nathan Gass <gass@search.ch>

=cut

use Web::Scraper;
use URI;
use URI::QueryParam;

my %config = (
	'pastebin|pb' => {
		url     => 'http://pastebin.com/post.php',
		post    => 'paste_code',
		params  => {
			submit_hidden => 'submit_hidden',
			paste_format  => 1,
			paste_expire_date => 'N',
			paste_private => 0,
			paste_name => '',
		},
	},
	'google|g' => {
		url => 'http://www.google.com/search',
		params => {'q' => '$query', num => '$numresults'},
		results => scraper {process 'p > a', '[]' => sub {
			my $url = $_[0]->attr('href');
			my $q = URI->new($url)->query_param('q');
			return $q =~ m[^http://] ? $q : undef;
		}},
	},
	'man|m' => {
		url => 'http://localhost/cgi-bin/man/man2html',
		params => {query => '$query'},
		results => scraper {process 'ul > li > a', '[]' => '@href'},
	},
	'cpan|c' => {
		url => 'http://search.cpan.org/search?mode=all&query=$query',
		params => {query => '$query', pagesize => '$numresults'},
		results => scraper {process 'h2 > a', '[]' => '@href'},
	},
	'dwww|d' => {
		url => 'http://localhost/cgi-bin/dwww',
		params => {search => '$query'},
		results => scraper {process 'table.wide > tr > td > a', '[]' => '@href'}
	},
	);

use strict;
use warnings;

use 5.010;

use Getopt::Long;
use Pod::Usage;
use IO::All;
use IO::All::LWP;
use List::Util qw/first max/;
use Browser::Open qw/open_browser_cmd/;
use YAML::XS qw/LoadFile Dump/;
use Hash::Merge qw/merge/;

my %opts;
%opts = (
	'windows'   => 0,
	'tabs'      => sub {$opts{windows} = 0},
	'config'    => glob('~/.psrrc'),
	'configdir' => glob('~/.psr'),
);
Getopt::Long::Configure('gnu_getopt');
GetOptions(
	\%opts,
	'help|h', 'first|lucky|f', 'url|u', 'list|l', 'num|n=i',
	'providers|p', 'browser=s', 'all|a', "open|o:s",
	'windows|window|w', 'tabs|tab|t', 'dump|d', 'read|r:s',
	'config|c', 'configdir', 'man',
	) or pod2usage(2);
pod2usage(1) if $opts{help};
pod2usage(-verbose => 2, -exitval => 0) if ($opts{man});
delete $opts{tabs};

if (-e $opts{config}) {
	my $userconfig = LoadFile($opts{config});
	foreach my $key (keys %$userconfig) {
		$userconfig->{$key}->{results} = eval $userconfig->{$key}->{results}
			if $userconfig->{$key}->{results};
	}
	%config = %{ merge($userconfig, \%config) };
}

if (-d $opts{configdir}) {
	foreach my $file (io($opts{configdir})->all_files) {
		my $conf = LoadFile($file);
		my $key  = delete $conf->{key} || $file->filename;
		$conf->{results} = eval $conf->{results}
			if $conf->{results};
		$config{$key} = $conf;
	}
}

if ($opts{providers}) {
	say sprintf("%-10s", $_), $config{$_}{url} foreach keys %config;
	exit(0);
}

if ($opts{list}) {
	$opts{url} = 1;
	$opts{open} = $opts{open} || "1-";
	delete $opts{list};
}

if ($opts{all}) {
	$opts{open} = "1-";
} elsif ($opts{first}) {
	$opts{open} = "1";
}
delete $opts{$_} foreach qw/list all first/;

if (!$opts{num}) {
	if ($opts{open} && $opts{open} !~ /-$|-,/) {
		my @nums = ($opts{open} =~ /(\d+)/g);
		$opts{num} = max @nums;
	} else {
		$opts{num} = 10;
	}
}

my $method = shift;
my $query = join ' ', @ARGV;
my $mconf = $config{ first { ($method =~ /^($_)$/) } keys %config };
die "Unknown method '$method'" unless $mconf;

my @urls = make_url($mconf, $query, \%opts);

if ($mconf->{post}) {
	my $post < io($opts{post} || '-');
	@urls = post($mconf, $urls[0], $post);
}

if (defined $opts{dump}) {
	my $html = get_page($urls[0], \%opts);
	print $html;
} else {
	if (defined $opts{open}) {
		my $html = get_page($urls[0], \%opts);
		my @all = scrape_page($mconf, $urls[0], $html, $opts{num});
		@urls = ();
		my $total = scalar @all;
		foreach (split ",", $opts{open}) {
			if (/(\d*)-(\d*)/) {
				my $first = ($1 || 1) - 1;
				my $last  = ($2 || $total) - 1;
				push @urls, @all[$first..$last];
			} elsif(/(\d+)/) {
				push @urls, $all[$1-1];
			} else {
				die "Illegal range '$_'";
			}
		}
		@urls = grep {$_} @urls;
	}

	if ($opts{url}) {
		say $_ foreach @urls;
	} else {
		my $cmd = $opts{browser} || open_browser_cmd();
		if ($opts{windows}) {
			system($cmd, $_) foreach @urls;
		} else {
			system($cmd, @urls);
		}
	}
}

sub make_url { 
	my ($mconf, $query, $opts) = @_;
	my $url = URI->new($mconf->{url});
	my $numresults = $opts->{num};
	my %params;
	foreach my $key (keys %{$mconf->{params}}) {
		no warnings 'uninitialized';
		my $val = eval '"' . $mconf->{params}{$key} . '"';
		$params{$key} = $val if $val;
	}
	$url->query_form(\%params);
	return $url;
}

sub get_page {
	my ($url, $opts) = @_;
	my $html;
	if (defined $opts->{read}) {
		$html < io($opts->{read} || '-');
	} else {
		$html < io($url)->ua(agent => 'Mozilla/4.0');
	}
	return $html;
}

sub post {
	my ($mconf, $url, $post) = @_;
	my $ua = LWP::UserAgent->new;
	$ua->agent('Mozilla/4.0');
	my $res = $ua->post(
		$url,
		Content => {%{$mconf->{params}}, $mconf->{post} => $post},
		Content_Type => 'multipart/form-data',
		);
	if ($res->is_redirect) {
		$url = URI->new_abs($res->header('Location'), $url)->as_string;
	}
	return $url;
}

sub scrape_page {
	my ($mconf, $url, $html, $num) = @_;
	return $url unless $mconf->{results};
	my $res = $mconf->{results}->scrape($html, $url);
	return $url unless $res->{''};
	my @defined = grep {$_} @{$res->{''}};
	warn "Not enough results!" if @defined < $num;
	return $num ? @defined[0..($num-1)] : @defined;
}

